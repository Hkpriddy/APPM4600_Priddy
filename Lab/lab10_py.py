# -*- coding: utf-8 -*-
"""Lab10.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IAi4aQ3zeMiN3i0G_CQnphRCYhVxiY8k
"""

import matplotlib.pyplot as plt
import numpy as np
import numpy.linalg as la
import math
import scipy
from scipy.integrate import quad

def eval_legendre(n, x):
  p = np.zeros(n+1)

  for i in range(0, n+1):
    if i == 0:
      p[i] = 1
    elif i == 1:
      p[i] = x
    else:
      p[i] = ((1/i) *((2*i-1)*x*p[i-1] - (i-1)*p[i-2]))
  return np.array(p)

def leg_poly(j,x):
  p=eval_legendre(j,x)[-1]
  return p


def driver():

#  function you want to approximate
    f = lambda x: 1/(1+x**2)

# Interval of interest
    a = -1
    b = 1
# weight function
    w = lambda x: 1/(np.sqrt(1-x**2))

# order of approximation
    n = 2

#  Number of points you want to sample in [a,b]
    N = 1000
    xeval = np.linspace(a,b,N+1)
    pval = np.zeros(N+1)

    for kk in range(N+1):
      #pval[kk] = eval_legendre_expansion(f,a,b,w,n,xeval[kk])
      pval[kk]  = Cheb_Expansion(f,a,b,w,n,xeval[kk])
    ''' create vector with exact values'''
    fex = np.zeros(N+1)
    for kk in range(N+1):
        fex[kk] = f(xeval[kk])

    plt.figure()
    plt.plot(xeval,fex,'ro-', label= 'f(x)')
    plt.plot(xeval,pval,'bs--',label= 'Expansion')
    plt.legend()
    plt.show()

    err = abs(pval-fex)
    plt.semilogy(xeval,err,'ro--',label='error')
    plt.legend()
    plt.show()



def eval_legendre_expansion(f,a,b,w,n,x):

#   This subroutine evaluates the Legendre expansion

#  Evaluate all the Legendre polynomials at x that are needed
# by calling your code from prelab
  p = eval_legendre(n,x)
  # initialize the sum to 0
  pval = 0.0
  for j in range(0,n+1):
      # make a function handle for evaluating phi_j(x)
      phi_j = lambda x:leg_poly(j,x)
      # make a function handle for evaluating phi_j^2(x)*w(x)
      phi_j_sq = lambda x: phi_j(x)**2 * w(x)
      # use the quad function from scipy to evaluate normalizations
      norm_fac,err = scipy.integrate.quad(phi_j_sq, a,b)
      # make a function handle for phi_j(x)*f(x)*w(x)/norm_fac
      func_j = lambda x:phi_j(x)*f(x)*w(x)/norm_fac
      # use the quad function from scipy to evaluate coeffs
      aj,err = scipy.integrate.quad(func_j, a, b)
      # accumulate into pval
      pval = pval+aj*p[j]

  return pval


def CHEBY(n,x):
  p = np.zeros(n+1)

  for i in range(0, n+1):
    if i == 0:
      p[i] = 1
    elif i == 1:
      p[i] = x
    else:
      p[i] = 2*x*p[i-1] - p[i-2]
  return np.array(p)


def cheby_poly(j,x):
  p=CHEBY(j,x)[-1]
  return p

def Cheb_Expansion(f,a,b,w,n,x):

#   This subroutine evaluates the Legendre expansion

#  Evaluate all the Legendre polynomials at x that are needed
# by calling your code from prelab
  p = CHEBY(n,x)
  # initialize the sum to 0
  pval = 0.0
  for j in range(0,n+1):
      # make a function handle for evaluating phi_j(x)
      phi_j = lambda x:cheby_poly(j,x)
      # make a function handle for evaluating phi_j^2(x)*w(x)
      phi_j_sq = lambda x: phi_j(x)**2 * w(x)
      # use the quad function from scipy to evaluate normalizations
      norm_fac,err = scipy.integrate.quad(phi_j_sq, a,b)
      # make a function handle for phi_j(x)*f(x)*w(x)/norm_fac
      func_j = lambda x:phi_j(x)*f(x)*w(x)/norm_fac
      # use the quad function from scipy to evaluate coeffs
      aj,err = scipy.integrate.quad(func_j, a, b)
      # accumulate into pval
      pval = pval+aj*p[j]

  return pval

driver()